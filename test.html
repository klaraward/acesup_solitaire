<!DOCTYPE html>
<html lang="sv">

<head>
    <meta charset="UTF-8">
    <title>Aces Up - Tester</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }

        .pass {
            color: #4ade80;
        }

        .fail {
            color: #f87171;
        }

        h2 {
            color: #fbbf24;
            margin-top: 30px;
        }

        .summary {
            margin-top: 30px;
            padding: 15px;
            background: #2d2d44;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <h1>Aces Up - Unit Tester</h1>
    <div id="results"></div>

    <!-- Dold spelcontainer för att mocka DOM -->
    <div style="display:none">
        <div id="deck"></div>
        <div id="slot-0"></div>
        <div id="slot-1"></div>
        <div id="slot-2"></div>
        <div id="slot-3"></div>
        <div id="cards-left"></div>
        <div id="status"></div>
        <div id="greeting"></div>
        <button id="restart-btn"></button>
        <input type="radio" name="hints-mode" value="off">
        <input type="radio" name="hints-mode" value="exists">
        <input type="radio" name="hints-mode" value="show" checked>
        <input type="checkbox" id="colorful-suits">
        <p id="quota-display"></p>
        <p id="player-count"></p>
    </div>

    <script>
        // Mocka prompt och localStorage med fungerande storage
        window.prompt = () => 'Test';
        const mockStorage = {};
        window.localStorage = {
            getItem: (key) => mockStorage[key] || null,
            setItem: (key, value) => { mockStorage[key] = value; },
            removeItem: (key) => { delete mockStorage[key]; },
            clear: () => { Object.keys(mockStorage).forEach(k => delete mockStorage[k]); }
        };
    </script>

    <script src="game.js"></script>

    <script>
        const resultsEl = document.getElementById('results');
        let passed = 0;
        let failed = 0;

        function card(rank, suit) {
            return { rank, suit, value: rankValues[rank] };
        }

        function test(name, fn) {
            try {
                gameOver = false;
                fn();
                resultsEl.innerHTML += `<div class="pass">✓ ${name}</div>`;
                passed++;
            } catch (e) {
                resultsEl.innerHTML += `<div class="fail">✗ ${name}<br>&nbsp;&nbsp;${e.message}</div>`;
                failed++;
            }
        }

        function expect(actual) {
            return {
                toBe(expected) {
                    if (actual !== expected) {
                        throw new Error(`Förväntade ${expected}, fick ${actual}`);
                    }
                }
            };
        }

        // === checkGameOver tester ===
        resultsEl.innerHTML += '<h2>checkGameOver tester</h2>';

        test('avslutar spelet när kortlek tom, inga kort kan tas bort, inga tomma platser', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(true);
        });

        test('avslutar spelet när kortlek tom och två ess på varandra (BUGG-SCENARIO 1)', () => {
            deck = [];
            slots = [
                [card('A', '♣')],  // Klöver ess ensam
                [card('K', '♥')],  // Hjärter kung ensam
                [card('A', '♦')],  // Ruter ess ensam
                [card('A', '♥'), card('A', '♠')]   // Spader ess överst, hjärter ess under
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(true);
        });

        test('avslutar spelet när kortlek tom och ess i alla högar med kort under (BUGG-SCENARIO 2)', () => {
            deck = [];
            slots = [
                [card('A', '♣')],  // Klöver ess ensam
                [card('A', '♥')],  // Hjärter ess ensam
                [card('A', '♦')],  // Ruter ess ensam
                [card('K', '♦'), card('K', '♣'), card('K', '♠'), card('K', '♥'), card('A', '♠')]   // Spader ess överst, alla kungar underst
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(true);
        });

        test('avslutar INTE spelet om kort kan flyttas (BUGG-SCENARIO 3)', () => {
            deck = [];
            slots = [
                [card('A', '♣')],  // Klöver ess ensam
                [],  // tomt
                [card('A', '♦')],  // Ruter ess ensam
                [card('K', '♦'), card('K', '♣'), card('K', '♠'), card('K', '♥'), card('A', '♥'), card('A', '♠')]   // Spader ess överst, alla kungar underst
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(false);
        });

        test('avslutar INTE spelet om kort kan tas bort', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [card('K', '♥')],  // Kan tas bort pga hjärter ess
                [card('A', '♦')],
                [card('A', '♥')]   // Hjärter ess synligt
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(false);
        });

        test('avslutar INTE spelet om kortleken har kort kvar', () => {
            deck = [card('2', '♠')];
            slots = [
                [card('A', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(false);
        });

        test('avslutar spelet även om det finns tomma platser (om inga kort kan tas bort). (Ett scenario som inte borde hända)', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [],  // Tom plats
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            gameOver = false;
            checkGameOver();
            expect(gameOver).toBe(true);
        });

        // === canBeRemoved tester ===
        resultsEl.innerHTML += '<h2>canBeRemoved tester</h2>';

        test('returnerar true om högre kort med samma färg finns synligt', () => {
            slots = [
                [card('K', '♥')],
                [card('A', '♥')],
                [card('5', '♦')],
                [card('2', '♣')]
            ];
            expect(canBeRemoved(0)).toBe(true);
            expect(canBeRemoved(1)).toBe(false);
        });

        test('returnerar false om högre kort är dolt under annat kort', () => {
            slots = [
                [card('K', '♥')],                   // Kung - kan EJ tas bort
                [card('A', '♥'), card('A', '♠')],  // Hjärter ess dolt under spader ess
                [card('5', '♦')],
                [card('2', '♣')]
            ];
            expect(canBeRemoved(0)).toBe(false);
        });

        test('returnerar false för ess (alltid högst)', () => {
            slots = [
                [card('A', '♥')],
                [card('K', '♦')],
                [card('5', '♦')],
                [card('2', '♣')]
            ];
            expect(canBeRemoved(0)).toBe(false);
        });

        // === countScore tester ===
        resultsEl.innerHTML += '<h2>countScore tester</h2>';

        test('räknar totalt antal kort i alla högar', () => {
            slots = [
                [card('A', '♠'), card('2', '♠')],
                [card('A', '♥')],
                [],
                [card('A', '♣'), card('3', '♣'), card('4', '♣')]
            ];
            expect(countScore()).toBe(6);
        });

        test('returnerar 4 för perfekt vinst', () => {
            slots = [
                [card('A', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            expect(countScore()).toBe(4);
        });

        // === Kvot-tester ===
        resultsEl.innerHTML += '<h2>Kvot-tester</h2>';

        test('getTodayKey returnerar dagens datum', () => {
            const key = getTodayKey();
            const today = new Date().toISOString().split('T')[0];
            expect(key).toBe('gamesPlayed_' + today);
        });

        test('getGamesPlayedToday returnerar 0 om inget spelat', () => {
            localStorage.clear();
            expect(getGamesPlayedToday()).toBe(0);
        });

        test('incrementGamesPlayed ökar räknaren', () => {
            localStorage.clear();
            expect(getGamesPlayedToday()).toBe(0);
            incrementGamesPlayed();
            expect(getGamesPlayedToday()).toBe(1);
            incrementGamesPlayed();
            expect(getGamesPlayedToday()).toBe(2);
        });

        test('hasQuotaLeft returnerar false när kvoten är slut', () => {
            localStorage.clear();
            // Sätt kvoten till max
            localStorage.setItem(getTodayKey(), DAILY_QUOTA.toString());
            expect(hasQuotaLeft()).toBe(false);
        });

        test('hasQuotaLeft returnerar true när kvot finns kvar', () => {
            localStorage.clear();
            localStorage.setItem(getTodayKey(), '5');
            expect(hasQuotaLeft()).toBe(true);
        });

        test('kvoten resettas nästa dag (olika datum-nycklar)', () => {
            localStorage.clear();
            // Simulera att vi spelade igår
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayKey = 'gamesPlayed_' + yesterday.toISOString().split('T')[0];
            localStorage.setItem(yesterdayKey, DAILY_QUOTA.toString());

            // Dagens kvot ska vara 0 (ny dag)
            expect(getGamesPlayedToday()).toBe(0);
            expect(hasQuotaLeft()).toBe(true);
        });

        test('gårdagens kvot påverkar inte dagens', () => {
            localStorage.clear();
            // Sätt gårdagens kvot till max
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayKey = 'gamesPlayed_' + yesterday.toISOString().split('T')[0];
            localStorage.setItem(yesterdayKey, '10');

            // Sätt dagens till 3
            localStorage.setItem(getTodayKey(), '3');

            // Ska läsa dagens värde, inte gårdagens
            expect(getGamesPlayedToday()).toBe(3);
            expect(hasQuotaLeft()).toBe(true);
        });

        // === hasPerfectPosition tester ===
        resultsEl.innerHTML += '<h2>hasPerfectPosition tester</h2>';

        test('hasPerfectPosition returnerar true med 4 ess i varsina högar (spel klart)', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            expect(hasPerfectPosition()).toBe(true);
        });

        test('hasPerfectPosition returnerar true även med kort kvar i plockhögen', () => {
            deck = [card('2', '♠'), card('3', '♥')];
            slots = [
                [card('A', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            expect(hasPerfectPosition()).toBe(true);
        });

        test('hasPerfectPosition returnerar false om ett ess har kort under sig', () => {
            deck = [];
            slots = [
                [card('2', '♠'), card('A', '♠')],  // Ess med kort under
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            expect(hasPerfectPosition()).toBe(false);
        });

        test('hasPerfectPosition returnerar false om inte alla ess är på plats', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [card('K', '♥')],  // Kung istället för ess
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            expect(hasPerfectPosition()).toBe(false);
        });

        test('hasPerfectPosition returnerar false med tom hög', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [],  // Tom hög
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            expect(hasPerfectPosition()).toBe(false);
        });

        // === endGame tester ===
        resultsEl.innerHTML += '<h2>endGame tester</h2>';

        test('endGame visar "Grattis, du vann!" vid perfekt vinst', () => {
            deck = [];
            slots = [
                [card('A', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            gameOver = false;
            endGame();
            const statusEl = document.getElementById('status');
            expect(statusEl.innerHTML.includes('Grattis, du vann!')).toBe(true);
            expect(statusEl.innerHTML.includes('Poäng')).toBe(false);
        });

        test('endGame visar poäng om inte perfekt vinst', () => {
            deck = [];
            slots = [
                [card('A', '♠'), card('2', '♠')],
                [card('A', '♥')],
                [card('A', '♦')],
                [card('A', '♣')]
            ];
            gameOver = false;
            endGame();
            const statusEl = document.getElementById('status');
            expect(statusEl.innerHTML.includes('Poäng: 5')).toBe(true);
            expect(statusEl.innerHTML.includes('Grattis')).toBe(false);
        });

        // === canRemoveAfterExposing tester (dubbelklick) ===
        resultsEl.innerHTML += '<h2>canRemoveAfterExposing tester (dubbelklick)</h2>';

        test('canRemoveAfterExposing returnerar true om översta kortet är lägre än underkortet och samma svit', () => {
            slots = [
                [card('A', '♥'), card('K', '♥')],  // Kung på ess, samma svit - kan tas bort
                [card('5', '♦')],
                [card('2', '♣')],
                []
            ];
            expect(canRemoveAfterExposing(0)).toBe(true);
        });

        test('canRemoveAfterExposing returnerar false om översta kortet är högre än underkortet', () => {
            slots = [
                [card('K', '♥'), card('A', '♥')],  // Ess på kung - kan EJ tas bort (ess är högst)
                [card('5', '♦')],
                [card('2', '♣')],
                []
            ];
            expect(canRemoveAfterExposing(0)).toBe(false);
        });

        test('canRemoveAfterExposing returnerar false om korten har olika svit', () => {
            slots = [
                [card('A', '♥'), card('K', '♠')],  // Kung spader på ess hjärter - olika svit
                [card('5', '♦')],
                [card('2', '♣')],
                []
            ];
            expect(canRemoveAfterExposing(0)).toBe(false);
        });

        test('canRemoveAfterExposing returnerar false om högen bara har ett kort', () => {
            slots = [
                [card('K', '♥')],  // Bara ett kort
                [card('5', '♦')],
                [card('2', '♣')],
                []
            ];
            expect(canRemoveAfterExposing(0)).toBe(false);
        });

        test('canRemoveAfterExposing returnerar false för tom hög', () => {
            slots = [
                [],
                [card('5', '♦')],
                [card('2', '♣')],
                [card('A', '♥')]
            ];
            expect(canRemoveAfterExposing(0)).toBe(false);
        });

        test('handleSlotDoubleClick tar bort kort om tom plats finns och villkor uppfylls', () => {
            deck = [];
            slots = [
                [card('A', '♥'), card('K', '♥')],  // Kung på ess, samma svit
                [card('5', '♦')],
                [card('2', '♣')],
                []  // Tom plats
            ];
            gameOver = false;
            handleSlotDoubleClick(0);
            // Kungen ska vara borta, bara esset kvar
            expect(slots[0].length).toBe(1);
            expect(slots[0][0].rank).toBe('A');
            // Tomma platsen ska fortfarande vara tom (kortet togs bort direkt)
            expect(slots[3].length).toBe(0);
        });

        test('handleSlotDoubleClick gör inget om ingen tom plats finns', () => {
            deck = [];
            slots = [
                [card('A', '♥'), card('K', '♥')],  // Kung på ess, samma svit
                [card('5', '♦')],
                [card('2', '♣')],
                [card('3', '♠')]  // Ingen tom plats
            ];
            gameOver = false;
            handleSlotDoubleClick(0);
            // Inget ska ha ändrats
            expect(slots[0].length).toBe(2);
        });

        // Sammanfattning
        resultsEl.innerHTML += `<div class="summary"><strong>Resultat: ${passed} godkända, ${failed} misslyckade</strong></div>`;
    </script>
</body>

</html>